/* ########################################################################

   PICsim - PIC simulator http://sourceforge.net/projects/picsim/

   ########################################################################

   Copyright (c) : 2011  Luis Claudio Gambôa Lopes

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   For e-mail suggestions :  lcgamboa@yahoo.com
   ######################################################################## */

/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */

// LCD module connections
sbit LCD_RS at RE2_bit;
sbit LCD_EN at RE1_bit;
sbit LCD_D4 at RD4_bit;
sbit LCD_D5 at RD5_bit;
sbit LCD_D6 at RD6_bit;
sbit LCD_D7 at RD7_bit;

sbit LCD_RS_Direction at TRISE2_bit;
sbit LCD_EN_Direction at TRISE1_bit;
sbit LCD_D4_Direction at TRISD4_bit;
sbit LCD_D5_Direction at TRISD5_bit;
sbit LCD_D6_Direction at TRISD6_bit;
sbit LCD_D7_Direction at TRISD7_bit;
// End LCD module connections


#include "eeprom_ext.h"
#include "teclado.h"
#include "rtc.h"


unsigned char cnt;
unsigned int t1cont;

void interrupt()
 {
  cnt--;
  if(!cnt)
  {
//executada a cada 1 segundo
     TMR1ON_bit=0;
     t1cont=(((unsigned int)TMR1H<<8)|(TMR1L))/7; //ventilador com 7 p�s
     cnt=125; 
     TMR1H=0;
     TMR1L=0;
     TMR1ON_bit=1;
  }
  T0IF_bit=0;
  TMR0H=0;
  TMR0L=6; //250
}


void main() 
{
  unsigned char i;
  unsigned char tmp;
  unsigned int tmpi;

  char str[6];

  ADCON1=0x06;
  TRISA=0xC3;
  TRISB=0x01;
  TRISC=0x01;
  TRISD=0x00;
  TRISE=0x00;

  RBPU_bit=0;
  


  

  lcd_init();
  i2c1_init(10000);
  adc_init();
  
 /*
//dip
  TRISB=0x03;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Ligue todos DIP");
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp("Press. RB1");
  while(RB1_bit);
 */



//dip
  TRISB=0x03;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Desl. RTC e REL1");
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp("Press. RB1");
  while(RB1_bit);


//teste TEMP
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("   Teste TEMP");
  
  TRISA=0x07;
  ADCON1=0x02;

  for(i=0; i< 100; i++)
  {
    tmpi=(adc_read(2)*10)/2;
    lcd_cmd(_LCD_SECOND_ROW+5);
    inttostr(tmpi,str);
    lcd_chr_cp(str[3]);
    lcd_chr_cp(str[4]);
    lcd_chr_cp(',');
    lcd_chr_cp(str[5]);
    lcd_chr_cp('C');
    delay_ms(20);
  }


//teste Aquecimento
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("   Teste AQUEC");
  RC5_bit=1;
  for(i=0; i< 100; i++)
  {
    tmpi=(adc_read(2)*10)/2;
    lcd_cmd(_LCD_SECOND_ROW+5);
    inttostr(tmpi,str);
    lcd_chr_cp(str[3]);
    lcd_chr_cp(str[4]);
    lcd_chr_cp(',');
    lcd_chr_cp(str[5]);
    lcd_chr_cp('C');
    delay_ms(50);
  }
  RC5_bit=0;


//teste Resfriamento

  TRISC0_bit=1;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("   Teste RESFR");

//timer0 temporizador

 T0CS_bit=0;
 PSA_bit=0;
 T08BIT_bit=1;
 T0PS0_bit=0; // divide por 32
 T0PS1_bit=0;
 T0PS2_bit=1;
 TMR0ON_bit=1;

 T0IE_bit=1;

//T = 32x250x125 = 1segundo;

//timer1 contador
 TMR1CS_bit=1;
 T1CKPS1_bit=0;
 T1CKPS0_bit=0;


 T0IF_bit=0;
 TMR0H=0;
 TMR0L=6; //250
 cnt=125; 
 GIE_bit=1;

 TMR1H=0;
 TMR1L=0;
 TMR1ON_bit=1;

  RC2_bit=1;
  for(i=0; i< 150; i++)
  {
    tmpi=(adc_read(2)*10)/2;
    lcd_cmd(_LCD_SECOND_ROW+2);
    inttostr(tmpi,str);
    lcd_chr_cp(str[3]);
    lcd_chr_cp(str[4]);
    lcd_chr_cp(',');
    lcd_chr_cp(str[5]);
    lcd_chr_cp('C');

    lcd_cmd(_LCD_SECOND_ROW+8);
    inttostr(t1cont,str);
    lcd_chr_cp(str[2]);
    lcd_chr_cp(str[3]);
    lcd_chr_cp(str[4]);
    lcd_chr_cp(str[5]);
    lcd_chr_cp('R');
    lcd_chr_cp('P');
    lcd_chr_cp('S');

    delay_ms(30);
  }

  GIE_bit=0;
  RC2_bit=0;


ADCON1=0x06;

TRISC=0x18;

//teste RTC
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Teste RTC");
  
//ajuste  rtc_w();

//  rtc_w();
  rtc_r();
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(date);
   delay_ms(2000);
  for(i=0;i<20;i++)
  {
    rtc_r();
    lcd_cmd(_LCD_SECOND_ROW);;
    lcd_out_cp(time);
    delay_ms(500);
  }


//dip
  TRISB=0x03;
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Des. DIS* e LED1");
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp("Press. RB1");
  while(RB1_bit);



  TRISB=0xF8;
//teste Teclado
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW+2);
  lcd_out_cp("Teste Teclado");

  lcd_cmd(_LCD_SECOND_ROW+1);

  i=0;
  while(i<14)
  {
    TRISD=0x0F;
    tmp=tc_tecla(1500)+0x30;
    TRISD=0x00;
    lcd_chr_cp(tmp);
    i++;
  }



  TRISB=0x03;
//teste EEPROM INT
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Teste EEPROM INT");
// testar ? 
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(" (s=RB0 n=RB1) ?");


 // TRISB=0x03;

  while(RB0_bit && RB1_bit);

  if(RB0_bit == 0)
  {
    tmp=eeprom_read(10);
    lcd_chr_cp(tmp);

    eeprom_write(10,0xA5);
    eeprom_write(10,0x5A);
    i=eeprom_read(10);

    eeprom_write(10,tmp);

    lcd_cmd(_LCD_CLEAR);
    lcd_cmd(_LCD_FIRST_ROW);
    lcd_out_cp("Teste EEPROM INT");
    lcd_cmd(_LCD_SECOND_ROW);
    if(i == 0x5A) 
      lcd_out_cp("       OK");
    else
      lcd_out_cp("      ERRO");

    delay_ms(1000);
  }
  else
  {
    while(RB1_bit == 0);
  }



//teste EEPROM EXT
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("Teste EEPROM EXT");
// testar ? 
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(" (s=RB0 n=RB1) ?");

  TRISB=0x03;

  while(RB0_bit && RB1_bit);

  if(RB0_bit == 0)
  {
    tmp=e2pext_r(10);
    lcd_chr_cp(tmp);

    e2pext_w(10,0xA5);
    e2pext_w(10,0x5A);
    i=e2pext_r(10);

    e2pext_w(10,tmp);

    lcd_cmd(_LCD_CLEAR);
    lcd_cmd(_LCD_FIRST_ROW);
    lcd_out_cp("Teste EEPROM EXT");
    lcd_cmd(_LCD_SECOND_ROW);
    if(i == 0x5A) 
      lcd_out_cp("       OK");
    else
      lcd_out_cp("      ERRO");

    delay_ms(1000);
  }
  else
  {
    while(RB1_bit == 0);
  }

//  TRISB=0x00;
//  PORTB=0;


//fim teste 
  lcd_cmd(_LCD_CLEAR);
  lcd_cmd(_LCD_FIRST_ROW);
  lcd_out_cp("      Fim");
  lcd_cmd(_LCD_SECOND_ROW);
  lcd_out_cp(" Pressione RST");



   while(1);

}