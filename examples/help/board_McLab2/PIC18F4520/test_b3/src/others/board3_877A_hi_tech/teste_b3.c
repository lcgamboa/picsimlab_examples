/* ########################################################################

   PICsim - PIC simulator http://sourceforge.net/projects/picsim/

   ########################################################################

   Copyright (c) : 2010  Luis Claudio Gambôa Lopes

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   For e-mail suggestions :  lcgamboa@yahoo.com
   ######################################################################## */

/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */
#include <pic.h>

#include "atraso.h"
#include "lcd.h"
#include "display7s.h"
#include "i2c.h"
#include "serial.h"
#include "eeprom.h"
#include "eeprom_ext.h"
#include "adc.h"
#include "itoa.h"


__CONFIG(WDTDIS&  UNPROTECT & LVPDIS & BORDIS & PWRTEN & HS);

unsigned char cnt;
unsigned int t1cont;

void isr() interrupt 0 {                                                                                                   /* interrupt service routine */
  cnt--; 
  if(!cnt)
  {
//executada a cada 1 segundo
     TMR1ON=0;
     t1cont=(((unsigned int)TMR1H<<8)|(TMR1L))/7; //ventilador com 7 p�s
     cnt=125; 
     TMR1H=0;
     TMR1L=0;
     TMR1ON=1;
  }
  TMR2IF=0;
}

char* codetxt_to_ramtxt(const char* ctxt)
{
static char txt[45];
char i;
  for(i =0; txt[i] = ctxt[i]; i++);
  return txt;
}


void main() 
{
  unsigned char i;
  unsigned char tmp;
  unsigned int tmpi;

  char str[6];

  ADCON1=0x06;
  TRISA=0xFF;
  TRISB=0x00;
  TRISC=0x01;
  TRISD=0x00;
  TRISE=0x00;

  lcd_init();
  i2c_init();
  serial_init();
  adc_init();

//teste lcd
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste LCD"));
  
  for(i=32;i<128;i++)
  {
    if((i%16) == 0)lcd_cmd(L_L2);
    lcd_dat(i);
    atraso_ms(50);
  }

  atraso_ms(100);
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste LCD"));
  lcd_cmd(L_L2);
  lcd_str(codetxt_to_ramtxt("       Ok"));
  atraso_ms(500);

//testa display 7s

  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste 7 Seg"));


    RB7=1;
    for(i=0;i<4;i++)
    {
      PORTB=0x10<<i;  
      for(tmp=0;tmp<16;tmp++)
      {
        PORTD=display7s(tmp);	
        atraso_ms(200);	
      }
    }

  PORTD=0;
 
//testa LEDs

  lcd_cmd(L_CLR);
  lcd_cmd(L_L1+3);
  lcd_str(codetxt_to_ramtxt("Teste LEDs"));

  for(tmp=0;tmp<3;tmp++)
    {
      for(i=1;i < 16;i=i*2)
      { 
        PORTB=i;
        atraso_ms(200);  
      }
    }
  PORTB=0;
  for(i=0;i<4;i++)
  {
    PORTB^=0x0F;
    atraso_ms(200);
  }  

//testa chaves


  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("  Teste Chaves"));

  tmp=0;

  while((tmp & 0x0F) != 0x0F) 
  {
    TRISB=0x0F;

    if(RB0 == 0)
    {
      tmp|=0x01;
    }
    if(RB1 == 0)
    {
      tmp|=0x02;
    }
    if(RB2 == 0)
    {
      tmp|=0x04;
    }
    if(RB3 == 0)
    {
      tmp|=0x08;
    }
    
    TRISB=0x00;
    PORTB=tmp;
    atraso_ms(10);
  }
  PORTB=0; 


//teste EEPROM INT
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("Teste EEPROM INT"));
// testar ? 
  lcd_cmd(L_L2);
  lcd_str(codetxt_to_ramtxt(" (s=S1 n=S2) ?"));

  TRISB=0x03;

  while(RB0 && RB1);

  if(RB0 == 0)
  {
    tmp=e2prom_r(10);
    lcd_dat(tmp);

    e2prom_w(10,0xA5);
    e2prom_w(10,0x5A);
    i=e2prom_r(10);

    e2prom_w(10,tmp);

    lcd_cmd(L_CLR);
    lcd_cmd(L_L1);
    lcd_str(codetxt_to_ramtxt("Teste EEPROM INT"));
    lcd_cmd(L_L2);
    if(i == 0x5A) 
      lcd_str(codetxt_to_ramtxt("       OK"));
    else
      lcd_str(codetxt_to_ramtxt("      ERRO"));

    atraso_ms(1000);
  }
  else
  {
    while(RB1 == 0);
  }

  TRISB=0x00;
  PORTB=0;

//teste EEPROM EXT
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("Teste EEPROM EXT"));
// testar ? 
  lcd_cmd(L_L2);
  lcd_str(codetxt_to_ramtxt(" (s=S1 n=S2) ?"));

  TRISB=0x03;

  while(RB0 && RB1);

  if(RB0 == 0)
  {
    tmp=e2pext_r(10);
    lcd_dat(tmp);

    e2pext_w(10,0xA5);
    e2pext_w(10,0x5A);
    i=e2pext_r(10);

    e2pext_w(10,tmp);

    lcd_cmd(L_CLR);
    lcd_cmd(L_L1);
    lcd_str(codetxt_to_ramtxt("Teste EEPROM EXT"));
    lcd_cmd(L_L2);
    if(i == 0x5A) 
      lcd_str(codetxt_to_ramtxt("       OK"));
    else
      lcd_str(codetxt_to_ramtxt("      ERRO"));

    atraso_ms(1000);
  }
  else
  {
    while(RB1 == 0);
  }

  TRISB=0x00;
  PORTB=0;


//teste serial
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("Teste Serial TX"));
  lcd_cmd(L_L2+4);
  lcd_str(codetxt_to_ramtxt("9600 8N1"));

  serial_tx_str(codetxt_to_ramtxt("\r\n Picsimlab\r\n Teste Serial TX\r\n"));

  for(i=0;i<4;i++)
  {
    serial_tx(i+0x30);
    serial_tx_str(codetxt_to_ramtxt(" PicsimLab\r\n"));
  }
  atraso_ms(1000);

  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("Teste Serial RX"));
  serial_tx_str(codetxt_to_ramtxt(" Digite!\r\n"));
  for(i=0;i<32;i++)
  {
    if(!(i%16))
    {
       lcd_cmd(L_L2);
       serial_tx_str(codetxt_to_ramtxt("\r\n"));
    }
    tmp=serial_rx(2000);
    lcd_dat(tmp);
    serial_tx(tmp);
  }
  atraso_ms(100);


//teste ADC
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt(" Teste ADC (P2)"));

  for(i=0; i< 200; i++)
  {
    tmp=((unsigned int)adc_amostra(1)*10)/204;
    lcd_cmd(L_L2+6);
    itoa(tmp,str);
    lcd_dat(str[3]);
    lcd_dat(',');
    lcd_dat(str[4]);
    lcd_dat('V');
    atraso_ms(10);
  }



//teste TEMP
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste TEMP"));

  for(i=0; i< 100; i++)
  {
    tmpi=((unsigned int) adc_amostra(0)*81)/100;
    lcd_cmd(L_L2+5);
    itoa(tmpi,str);
    lcd_dat(str[2]);
    lcd_dat(str[3]);
    lcd_dat(',');
    lcd_dat(str[4]);
    lcd_dat('C');
    atraso_ms(10);
  }


//teste Aquecimento
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste AQUEC"));
  RC2=1;
  for(i=0; i< 100; i++)
  {
    tmpi=((unsigned int) adc_amostra(0)*81)/100;
    lcd_cmd(L_L2+5);
    itoa(tmpi,str);
    lcd_dat(str[2]);
    lcd_dat(str[3]);
    lcd_dat(',');
    lcd_dat(str[4]);
    lcd_dat('C');
    atraso_ms(10);
  }
  RC2=0;


//teste Resfriamento
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("   Teste RESFR"));

//timer2 temporizador

 
 T2CKPS0=1; // divide por 16
 T2CKPS1=1;

 TOUTPS3=0; //divide por 2
 TOUTPS2=0;
 TOUTPS1=0;
 TOUTPS0=1;

 TMR2IE=1;
 PR2=249;

 TMR2ON=1;

//T = 32x250x125 = 1segundo;

//timer1 contador
 TMR1CS=1;
 T1CKPS1=0;
 T1CKPS0=0;

 TMR2IF=0;
 cnt=125; 
 GIE=1;
 PEIE=1;

 TMR1H=0;
 TMR1L=0;
 TMR1ON=1;

  RC1=1;
  for(i=0; i< 150; i++)
  {
    tmpi=((unsigned int) adc_amostra(0)*81)/100;
    lcd_cmd(L_L2+2);
    itoa(tmpi,str);
    lcd_dat(str[2]);
    lcd_dat(str[3]);
    lcd_dat(',');
    lcd_dat(str[4]);
    lcd_dat('C');

    lcd_cmd(L_L2+8);
    itoa(t1cont,str);
    lcd_dat(str[1]);
    lcd_dat(str[2]);
    lcd_dat(str[3]);
    lcd_dat(str[4]);
    lcd_dat('R');
    lcd_dat('P');
    lcd_dat('S');

    atraso_ms(10);
  }

  GIE=0;
  RC1=0;

//fim teste 
  lcd_cmd(L_CLR);
  lcd_cmd(L_L1);
  lcd_str(codetxt_to_ramtxt("      Fim"));
  lcd_cmd(L_L2);
  lcd_str(codetxt_to_ramtxt(" Pressione RST"));

  serial_tx_str(codetxt_to_ramtxt("\r\n FIM!\r\n"));


   while(1);

}
