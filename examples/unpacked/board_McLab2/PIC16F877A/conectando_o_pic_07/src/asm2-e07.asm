; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                   CONECTANDO O PIC - RECURSOS AVANÇADOS                 *
; *                               EXEMPLO 7                                 *
; *                                                                         *
; *                NICOLÁS CÉSAR LAVINIA e DAVID JOSÉ DE SOUZA              *
; *                                                                         *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *   VERSÃO : 2.0                                                          *
; *     DATA : 24/02/2003                                                   *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                             DESCRIÇÃO GERAL                             *
; *                                                                         *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTE EXEMPLO FOI ELABORADO PARA EXPLICAR O FUNCIONAMENTO DA LEITURA/ESCRITA
;  TANTO NA MEMÓRIA DE DADOS QUANTO NA MEMÓRIA DE PROGRAMA.
;
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         CONFIGURAÇÕES PARA GRAVAÇÃO                     *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

 __CONFIG _CP_OFF & _CPD_OFF & _DEBUG_OFF & _LVP_OFF & _WRT_OFF & _BODEN_OFF & _PWRTE_ON & _WDT_ON & _XT_OSC

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                            DEFINIÇÃO DAS VARIÁVEIS                      *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTE BLOCO DE VARIÁVEIS ESTÁ LOCALIZADO LOGO NO INÍCIO DO BANCO 0

	CBLOCK	0X20			; POSIÇÃO INICIAL DA RAM

		FILTRO_BOTOES		; FILTRO PARA RUIDOS
		TEMPO_TURBO		; TEMPORIZADOR P/ TURBO DAS TECLAS

		TEMPO1
		TEMPO0			; CONTADORES P/ DELAY

		FLAG			; FLAG DE USO GERAL

		VALOR_DADOS		; VALOR ARMAZENADO NA MEMÓRIA
					; DE DADOS (8 BITS)

		VALOR_PROG_HIGH		; VALOR ARMAZENADO NA MEMÓRIA
		VALOR_PROG_LOW		; DE PROGRAMAS (14 BITS)

		AUX			; REGISTRADOR AUXILIAR DE USO GERAL

		ENDERECO_HIGH		; REGISTRADORES DE ENDEREÇO PARA
		ENDERECO_LOW		; ACESSO À MEMÓRIA DE DADOS E PROGRAMA
					; MAPEADOS NO BANCO 0 DA RAM

		DADO_LOW_00		; REGISTRADORES DE DADOS PARA
		DADO_HIGH_00		; ACESSO À MEMÓRIA DE DADOS E PROGRAMA
					; MAPEADOS NO BANCO 0 DA RAM

		DADO_LOW_01		; REGISTRADORES DE DADOS PARA
		DADO_HIGH_01		; ACESSO À MEMÓRIA DE DADOS E PROGRAMA
					; MAPEADOS NO BANCO 0 DA RAM

		DADO_LOW_10		; REGISTRADORES DE DADOS PARA
		DADO_HIGH_10		; ACESSO À MEMÓRIA DE DADOS E PROGRAMA
					; MAPEADOS NO BANCO 0 DA RAM

		DADO_LOW_11		; REGISTRADORES DE DADOS PARA
		DADO_HIGH_11		; ACESSO À MEMÓRIA DE DADOS E PROGRAMA
					; MAPEADOS NO BANCO 0 DA RAM
	ENDC

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                DEFINIÇÃO DAS VARIÁVEIS INTERNAS DO PIC                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  O ARQUIVO DE DEFINIÇÕES DO PIC UTILIZADO DEVE SER REFERENCIADO PARA QUE
;  OS NOMES DEFINIDOS PELA MICROCHIP POSSAM SER UTILIZADOS, SEM A NECESSIDADE
;  DE REDIGITAÇÃO.

	#INCLUDE <P16F877A.INC>		; MICROCONTROLADOR UTILIZADO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                      DEFINIÇÃO DOS BANCOS DE RAM                        *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  OS PSEUDOS-COMANDOS "BANK0" E "BANK1", AQUI DEFINIDOS, AJUDAM A COMUTAR
;  ENTRE OS BANCOS DE MEMÓRIA.

#DEFINE	BANK1	BSF	STATUS,RP0	; SELECIONA BANK1 DA MEMORIA RAM
#DEFINE	BANK0	BCF	STATUS,RP0	; SELECIONA BANK0 DA MEMORIA RAM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                           CONSTANTES INTERNAS                           *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  A DEFINIÇÃO DE CONSTANTES FACILITA A PROGRAMAÇÃO E A MANUTENÇÃO.

FILTRO_TECLA	EQU	.200		; FILTRO P/ EVITAR RUIDOS DOS BOTÕES

TURBO_TECLA	EQU	.60		; TEMPORIZADOR P/ TURBO DAS TECLAS

END_MEM_DADO	EQU	0X10		; ENDEREÇO P/ LEITURA E GRAVAÇÃO
					; NA MEMÓRIA DE DADOS

END_MEM_PROG_H	EQU	0X08		; ENDEREÇO P/ LEITURA E GRAVAÇÃO
END_MEM_PROG_L	EQU	0X00		; NA MEMÓRIA DE PROGRAMA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                    DECLARAÇÃO DOS FLAGs DE SOFTWARE                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  A DEFINIÇÃO DE FLAGs AJUDA NA PROGRAMAÇÃO E ECONOMIZA MEMÓRIA RAM.

#DEFINE	TIPO_MEMORIA	FLAG,0		; DEFINE A MEMORIA QUE ESTA SENDO
					;  UTILIZADA
					; 1 -> MEMORIA DE PROGRAMA
					; 0 -> MEMORIA DE DADOS

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                                ENTRADAS                                 *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  AS ENTRADAS DEVEM SER ASSOCIADAS A NOMES PARA FACILITAR A PROGRAMAÇÃO E
;  FUTURAS ALTERAÇÕES DO HARDWARE.

#DEFINE	BOTAO_0		PORTB,0		; ESTADO DO BOTÃO 0
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

#DEFINE	BOTAO_1		PORTB,1		; ESTADO DO BOTÃO 1
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

#DEFINE	BOTAO_2		PORTB,2		; ESTADO DO BOTÃO 2
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

#DEFINE	BOTAO_3		PORTB,3		; ESTADO DO BOTÃO 3
					; 1 -> LIBERADO
					; 0 -> PRESSIONADO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                                 SAÍDAS                                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  AS SAÍDAS DEVEM SER ASSOCIADAS A NOMES PARA FACILITAR A PROGRAMAÇÃO E
;  FUTURAS ALTERAÇÕES DO HARDWARE.

#DEFINE	DISPLAY		PORTD		; BARRAMENTO DE DADOS DO DISPLAY

#DEFINE	RS		PORTE,0		; INDICA P/ O DISPLAY UM DADO OU COMANDO
						; 1 -> DADO
						; 0 -> COMANDO

#DEFINE	ENABLE		PORTE,1		; SINAL DE ENABLE P/ DISPLAY
					; ATIVO NA BORDA DE DESCIDA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                   VETOR DE RESET DO MICROCONTROLADOR                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  POSIÇÃO INICIAL PARA EXECUÇÃO DO PROGRAMA

	ORG	0X0000			; ENDEREÇO DO VETOR DE RESET
	GOTO	CONFIG_			; PULA PARA CONFIG DEVIDO A REGIÃO
					; DESTINADA AS ROTINAS SEGUINTES

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                   ROTINA DE DELAY (DE 1MS ATÉ 256MS)                    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA É UMA ROTINA DE DELAY VARIÁVEL, COM DURAÇÃO DE 1MS X O VALOR PASSADO
;  EM WORK (W).

DELAY_MS
	MOVWF	TEMPO1			; CARREGA TEMPO1 (UNIDADES DE MS)
	MOVLW	.250
	MOVWF	TEMPO0			; CARREGA TEMPO0 (P/ CONTAR 1MS)

	CLRWDT				; LIMPA WDT (PERDE TEMPO)
	DECFSZ	TEMPO0,F		; FIM DE TEMPO0 ?
	GOTO	$-2			; NÃO - VOLTA 2 INSTRUÇÕES
					; SIM - PASSOU-SE 1MS
	DECFSZ	TEMPO1,F		; FIM DE TEMPO1 ?
	GOTO	$-6			; NÃO - VOLTA 6 INSTRUÇÕES
					; SIM
	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA DE UM CARACTER NO DISPLAY               *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA ENVIA UM CARACTER PARA O MÓDULO DE LCD. O CARACTER A SER
;  ESCRITO DEVE SER COLOCADO EM WORK (W) ANTES DE CHAMAR A ROTINA.

ESCREVE
	MOVWF	DISPLAY			; ATUALIZA DISPLAY (PORTD)
	NOP				; PERDE 1US PARA ESTABILIZAÇÃO
	BSF	ENABLE			; ENVIA UM PULSO DE ENABLE AO DISPLAY
	GOTO	$+1			; .
	BCF	ENABLE			; .

	MOVLW	.1
	CALL	DELAY_MS		; DELAY DE 1MS
	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA LINHA 1 DO LCD                          *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA ESCREVE A LINHA 1 DA TELA PRINCIPAL DO LCD, COM A FRASE:
;  LINHA 1 - "M.DADOS  M.PROG."

ATUALIZA_TELA_LINHA_1
	BCF	RS			; SELECIONA O DISPLAY P/ COMANDOS
	MOVLW	0X80			; COMANDO PARA POSICIONAR O CURSOR
	CALL	ESCREVE			; LINHA 0 / COLUNA 0
	BSF	RS			; SELECIONA O DISPLAY P/ DADOS

					; COMANDOS PARA ESCREVER AS
					; LETRAS DE "M.DADOS  M.PROG."
	MOVLW	'M'
	CALL	ESCREVE
	MOVLW	'.'
	CALL	ESCREVE
	MOVLW	'D'
	CALL	ESCREVE
	MOVLW	'A'
	CALL	ESCREVE
	MOVLW	'D'
	CALL	ESCREVE
	MOVLW	'O'
	CALL	ESCREVE
	MOVLW	'S'
	CALL	ESCREVE
	MOVLW	' '
	CALL	ESCREVE
	MOVLW	' '
	CALL	ESCREVE
	MOVLW	'M'
	CALL	ESCREVE
	MOVLW	'.'
	CALL	ESCREVE
	MOVLW	'P'
	CALL	ESCREVE
	MOVLW	'R'
	CALL	ESCREVE
	MOVLW	'O'
	CALL	ESCREVE
	MOVLW	'G'
	CALL	ESCREVE
	MOVLW	'.'
	CALL	ESCREVE

	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA LINHA 2 DO LCD                          *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA ESCREVE A LINHA 2 DA TELA PRINCIPAL DO LCD.
;  A ROTINA LEVA EM CONTA TODAS AS VARIÁVEIS PERTINENTES P/ FORMAR A LINHA 2.

ATUALIZA_TELA_LINHA_2
	BCF	RS			; SELECIONA O DISPLAY P/ COMANDO
	MOVLW	0XC1			; COMANDO PARA POSICIONAR O CURSOR
	CALL	ESCREVE			; LINHA 1 / COLUNA 1

	BSF	RS			; SELECIONA O DISPLAY P/ DADOS

	MOVLW	'>'
	BTFSC	TIPO_MEMORIA		; ESTÁ UTILIZANDO A MEMÓRIA DE DADOS ?
	MOVLW	' '			; NÃO - ESCREVE ESPAÇO EM BRANCO
	CALL	ESCREVE			; SIM - ESCREVE ">" NO DISPLAY

	SWAPF	VALOR_DADOS,W		; INVERTE NIBLE DO VALOR_DADOS
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	MOVF	VALOR_DADOS,W		; CARREGA WORK COM VALOR_DADOS
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	MOVLW	'h'
	CALL	ESCREVE			; ESCREVE "h" NO DISPLAY

	MOVLW	'<'
	BTFSC	TIPO_MEMORIA		; ESTÁ UTILIZANDO A MEMÓRIA DE DADOS ?
	MOVLW	' '			; NÃO - ESCREVE ESPAÇO EM BRANCO
	CALL	ESCREVE			; SIM - ESCREVE "<" NO DISPLAY

	MOVLW	' '
	CALL	ESCREVE
	MOVLW	' '
	CALL	ESCREVE
	MOVLW	' '
	CALL	ESCREVE			; ESPAÇOS EM BRANCO

	MOVLW	'>'
	BTFSS	TIPO_MEMORIA		; ESTÁ UTILIZANDO A MEMÓRIA DE PROGRAMA?
	MOVLW	' '			; NÃO - ESCREVE ESPAÇO EM BRANCO
	CALL	ESCREVE			; SIM - ESCREVE ">" NO DISPLAY

	SWAPF	VALOR_PROG_HIGH,W	; INVERTE NIBLE DO VALOR_PROG_HIGH
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	MOVF	VALOR_PROG_HIGH,W	; CARREGA WORK COM VALOR_PROG_HIGH
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	SWAPF	VALOR_PROG_LOW,W	; INVERTE NIBLE DO VALOR_PROG_LOW
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	MOVF	VALOR_PROG_LOW,W	; CARREGA WORK COM VALOR_PROG_LOW
	ANDLW	B'00001111'		; MASCARA BITS MAIS SIGNIFICATIVOS
	MOVWF	AUX			; SALVA EM AUXILIAR

	MOVLW	0X0A
	SUBWF	AUX,W			; AUX - 10d (ATUALIZA FLAG DE CARRY)
	MOVLW	0X30			; CARREGA WORK COM 30h
	BTFSC	STATUS,C		; RESULTADO É POSITIVO? (É UMA LETRA?)
	MOVLW	0X37			; SIM - CARREGA WORK COM 37h
					; NÃO - WORK FICA COM 30h (NÚMERO)
	ADDWF	AUX,W			; SOMA O WORK AO AUXILIAR
					; (CONVERSÃO ASCII)
	CALL	ESCREVE 		; ENVIA CARACTER AO DISPLAY LCD

	MOVLW	'h'
	CALL	ESCREVE			; ESCREVE "h" NO DISPLAY

	MOVLW	'<'
	BTFSS	TIPO_MEMORIA		; ESTÁ UTILIZANDO A MEMÓRIA DE PROGRAMA?
	MOVLW	' '			; NÃO - ESCREVE ESPAÇO EM BRANCO
	CALL	ESCREVE			; SIM - ESCREVE "<" NO DISPLAY

	RETURN

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA NA MEMÓRIA DE DADOS                     *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTA ROTINA ESCREVE UM DADO (8 BITS) NA MEMÓRIA DE DADOS (E2PROM).
; O DADO A SER GRAVADO DEVE SER PASSADO PELO REGISTRADOR DADO_LOW_00.
; O REGISTRADOR DADO_HIGH_00 NÃO É UTILIZADO POIS A MEMÓRIA É DE 8 BITS.
; O ENDEREÇO DEVE SER PASSADO PELO REGISTRADOR ENDERECO_LOW.
; O REGISTRADOR ENDERECO_HIGH NÃO É UTILIZADO, POIS A MEMÓRIA TEM 256 ENDER.

DATA_EEPROM_WRITE
	MOVF	DADO_LOW_00,W		; CARREGA NO WORK DADO P/ SER GRAVADO
	BANKSEL	EEDATA			; ALTERA P/ BANK DO REGISTRADOR EEDATA
	MOVWF	EEDATA			; SALVA DADO A SER GRAVADO EM EEDATA
					; (CARREGA DADO NO REGISTRADOR
					; CORRETO DO BANCO 2 DA RAM A PARTIR
					; DO REGISTRADOR DE USUÁRIO MAPEADO
					; NO BANCO 0 DA RAM)

	BANKSEL	ENDERECO_LOW		; ALTERA P/BANK DO REGIST. ENDERECO_LOW
	MOVF	ENDERECO_LOW,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	BANKSEL	EEADR			; ALTERA P/ BANK DO REGISTRADOR EEADR
	MOVWF	EEADR			; SALVA ENDERECO EM EEADR
					; (CARREGA ENDEREÇO NO REGISTRADOR
					; CORRETO DO BANCO 2 DA RAM A PARTIR
					; DO REGISTRADOR DE USUÁRIO MAPEADO
					; NO BANCO 0 DA RAM)

	BANKSEL	EECON1			; ALTERA P/ BANK DO REGISTRADOR EECON1
	BCF	EECON1,EEPGD		; APONTA P/ MEMÓRIA DE DADOS
	BSF	EECON1,WREN		; HABILITA ESCRITA

	MOVLW	0X55
	MOVWF	EECON2			; ESCREVE 0X55 EM EECON2 (OBRIGATÓRIO)
	MOVLW	0XAA
	MOVWF	EECON2			; ESCREVE 0XAA EM EECON2 (OBRIGATÓRIO)
	BSF	EECON1,WR		; INICIA ESCRITA

	BTFSC	EECON1,WR		; ACABOU ESCRITA ?
	GOTO	$-1			; NÃO - AGUARDA FIM DA ESCRITA
					; SIM
	BCF	EECON1,WREN		; DESABILITA ESCRITAS NA MEMÓRIA

	BANKSEL 0X20			; VOLTA P/ BANK0
	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE LEITURA NA MEMÓRIA DE DADOS                     *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTA ROTINA LÊ UM DADO (8 BITS) DA MEMÓRIA DE DADOS (E2PROM).
; O DADO A SER LIDO É RETORNADO NO REGISTRADOR DADO_LOW_00.
; O REGISTRADOR DADO_HIGH_00 NÃO É UTILIZADO POIS A MEMÓRIA É DE 8 BITS.
; O ENDEREÇO DEVE SER PASSADO PELO REGISTRADOR ENDERECO_LOW.
; O REGISTRADOR ENDERECO_HIGH NÃO É UTILIZADO, POIS A MEMÓRIA TEM 256 ENDER.

DATA_EEPROM_READ
	MOVF	ENDERECO_LOW,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	BANKSEL	EEADR			; ALTERA P/ BANK DO REGISTRADOR EEADR
	MOVWF	EEADR			; SALVA ENDERECO EM EEADR
					; (CARREGA ENDERECO NO REGISTRADOR
					; CORRETO DO BANCO 2 DA RAM A PARTIR
					; DO REGISTRADOR DE USUÁRIO MAPEADO
					; NO BANCO 0 DA RAM)

	BANKSEL	EECON1			; ALTERA P/ BANK DO REGISTRADOR EECON1
	BCF	EECON1,EEPGD		; APONTA P/ MEMÓRIA DE DADOS
	BSF	EECON1,RD		; HABILITA LEITURA

	BANKSEL	EEDATA			; ALTERA P/BANK DO REGISTRADOR EEDATA
	MOVF	EEDATA,W		; SALVA DADO LIDO NO WORK
	BANKSEL DADO_LOW_00		; ALTERA P/BANK DO REGIST. DADO_LOW_00
	MOVWF	DADO_LOW_00		; SALVA DADO LIDO EM DADO_LOW_00
					; (SALVA DADO LIDO NO REGISTRADOR
					; DE USUÁRIO MAPEADO NO BANCO 0 DA RAM
					; A PARTIR DO REGISTRADOR UTILIZADO
					; PELO MICROCONTROLADOR MAPEADO
					; NO BANCO 2 DA RAM)

	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA NA MEMÓRIA DE PROGRAMA                  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; A ESCRITA NA MEMÓRIA DE PROGRAMA É FEITA DE 4 EM 4 WORDS OU DE 8 EM 8 BYTES
; OBRIGATORIAMENTE. O ENDEREÇO DEVE OBRIGATORIAMENTE ESTAR ALINHADO, OU SEJA,
; O ENDEREÇO INICIAL DEVERÁ SEMPRE TER OS ÚLTIMOS DOIS BITS EM 00. DESTA FORMA,
; SEMPRE A ESCRITA NA MEMÓRIA DE PROGRAMA É FEITA NOS ENDEREÇOS COM FINAIS 00,
; 01, 10 E 11, COMPLETANDO ASSIM 4 WORDS.
; ESTA ROTINA ESCREVE QUATRO WORDS (14 BITS) NA MEMÓRIA DE PROGRAMA.
; OS VAORES A SEREM SALVOS DEVEM SER PASSADOS PELOS REGISTRADORES
; DADO_HIGH_00:DADO_LOW_00, DADO_HIGH_01:DADO_LOW_01,
; DADO_HIGH_10:DADO_LOW_10 E DADO_HIGH_11:DADO_LOW_11.
; O ENDEREÇO DEVE SER PASSADO PELOS REGIST. ENDERECO_HIGH E ENDERECO_LOW.

FLASH_PROGRAM_WRITE
	MOVF	ENDERECO_HIGH,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	BANKSEL	EEADRH			; ALTERA P/ BANK DO REGISTRADOR EEADH
	MOVWF	EEADRH			; SALVA ENDERECO EM EEADH
	BANKSEL	ENDERECO_LOW		; ALTERA P/BANK DO REGIST. ENDERECO_LOW
	MOVF	ENDERECO_LOW,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	ANDLW	B'11111100'		; MASCARA PARA ZERAR OS ÚLTIMOS DOIS BIT
	BANKSEL	EEADR			; ALTERA P/ BANK DO REGISTRADOR EEADR
	MOVWF	EEADR			; SALVA ENDERECO EM EEADR
					; (CARREGA ENDEREÇO NOS REGISTRADOS
					; CORRETOS DO BANCO 2 DA RAM A PARTIR
					; DOS REGISTRADORES DE USUÁRIO MAPEADOS
					; NO BANCO 0 DA RAM)

	MOVLW	DADO_LOW_00		; CARREGA NO W ENDEREÇO DO REGISTRADOR DADO_HIGH_00
	MOVWF	FSR			; SALVA O ENDEREÇO DO REGISTRADOR NO FSR

FLASH_PROGRAM_WRITE_2
	BANKSEL	EEDATA			; ALTERA P/ BANK DO REGISTRADOR EEDATA
	MOVF	INDF,W			; CARREGA NO W O VALOR A SER SALVO
	MOVWF	EEDATA			; SALVA DADO A SER GRAVADO EM EEDATA
	INCF	FSR,F			; INCREMENTA PONTEIRO
	MOVF	INDF,W			; CARREGA NO W O VALOR A SER SALVO
	MOVWF	EEDATH			; SALVA DADO A SER GRAVADO EM EEDATH
	INCF	FSR,F			; INCREMENTA PONTEIRO

	BANKSEL	EECON1			; ALTERA P/ BANK DO REGISTRADOR EECON1
	BSF	EECON1,EEPGD		; APONTA P/ MEMÓRIA DE PROGRAMA
	BSF	EECON1,WREN		; HABILITA ESCRITA

	MOVLW	0X55
	MOVWF	EECON2			; ESCREVE 0X55 EM EECON2 (OBRIGATÓRIO)
	MOVLW	0XAA
	MOVWF	EECON2			; ESCREVE 0XAA EM EECON2 (OBRIGATÓRIO)
	BSF	EECON1,WR		; INICIA ESCRITA

	NOP
	NOP				; NÃO OPERA
	
	BCF	EECON1,WREN		; DESABILITA ESCRITAS NA MEMÓRIA
	
	BANKSEL	EEADR			; ALTERA P/ BANK DO REGISTRADOR EEADR
	INCF	EEADR,F			; INCREMENTA ENDEREÇO
	
	MOVLW	B'00000011'		; CARREGA MASCARA NO WORK
	ANDWF	EEADR,W			; WORK FICA COM APENAS OS ÚLTIMOS DOIS BITS DO ENDEREÇO
	BTFSS	STATUS,Z		; DEVE ESCREVER MAIS ALGUM DADO ? (WORK DIFERENTE DE ZERO?)
	GOTO	FLASH_PROGRAM_WRITE_2	; SIM - VOLTA PARA ESCRITA
					; NÃO

	BANKSEL	EECON1			; ALTERA P/ BANK DO REGISTRADOR EECON1
	
	BTFSC	EECON1,WR		; ACABOU ESCRITA ?
	GOTO	$-1			; NÃO - AGUARDA FIM DA ESCRITA
					; SIM

	BANKSEL 0X20			; VOLTA P/ BANK0
	RETURN				; RETORNA DA SUBROTINA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE LEITURA NA MEMÓRIA DE DADOS                     *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTA ROTINA LÊ UM DADO (14 BITS) DA MEMÓRIA DE PROGRAMA.
; O DADO LIDO É RETORNADO NOS REGISTRADORES DADO_HIGH_00 E DADO_LOW._00
; O ENDEREÇO DEVE SER PASSADO PELOS REGIST. ENDERECO_HIGH E ENDERECO_LOW.

FLASH_PROGRAM_READ
	MOVF	ENDERECO_HIGH,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	BANKSEL	EEADRH			; ALTERA P/ BANK DO REGISTRADOR EEADH
	MOVWF	EEADRH			; SALVA ENDERECO EM EEADH
	BANKSEL	ENDERECO_LOW		; ALTERA P/BANK DO REGIST. ENDERECO_LOW
	MOVF	ENDERECO_LOW,W		; CARREGA NO WORK O ENDEREÇO DE DESTINO
	BANKSEL	EEADR			; ALTERA P/ BANK DO REGISTRADOR EEADR
	MOVWF	EEADR			; SALVA ENDERECO EM EEADR
					; (CARREGA ENDEREÇO NOS REGISTRADOS
					; CORRETOS DO BANCO 2 DA RAM A PARTIR
					; DOS REGISTRADORES DE USUÁRIO MAPEADOS
					; NO BANCO 0 DA RAM)

	BANKSEL	EECON1			; ALTERA P/ BANK DO REGISTRADOR EECON1
	BSF	EECON1,EEPGD		; APONTA P/ MEMÓRIA DE PROGRAMA
	BSF	EECON1,RD		; HABILITA LEITURA

	NOP
	NOP

	BANKSEL	EEDATH			; ALTERA P/ BANK DO REGISTRADOR EEDATH
	MOVF	EEDATH,W		; SALVA DADO LIDO NO WORK
	BANKSEL	DADO_HIGH_00		; ALTERA P/ BANK DO REGIST. DADO_HIGH
	MOVWF	DADO_HIGH_00		; SALVA DADO LIDO EM DADO_HIGH_00
	BANKSEL	EEDATA			; ALTERA P/ BANK DO REGISTRADOR EEDATA_00
	MOVF	EEDATA,W		; SALVA DADO LIDO NO WORK
	BANKSEL	DADO_LOW_00		; ALTERA P/ BANK DO REGIST. DADO_LOW_00
	MOVWF	DADO_LOW_00		; SALVA DADO LIDO EM DADO_LOW_00
					; (SALVA DADO LIDO NOS REGISTRADORES
					; DE USUÁRIO MAPEADOS NO BANCO 0 DA RAM
					; A PARTIR DOS REGISTRADORES UTILIZADOS
					; PELO MICROCONTROLADOR MAPEADOS
					; NO BANCO 2 DA RAM)

	RETURN				; RETORNA

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                CONFIGURAÇÕES INICIAIS DE HARDWARE E SOFTWARE            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  NESTA ROTINA SÃO INICIALIZADAS AS PORTAS DE I/O DO MICROCONTROLADOR E AS
;  CONFIGURAÇÕES DOS REGISTRADORES ESPECIAIS (SFR). A ROTINA INICIALIZA A
;  MÁQUINA E AGUARDA O ESTOURO DO WDT.

CONFIG_
	CLRF	PORTA			; GARANTE TODA AS SAÍDAS EM ZERO
	CLRF	PORTB
	CLRF	PORTC
	CLRF	PORTD
	CLRF	PORTE

	BANK1				; SELECIONA BANCO 1 DA RAM

	MOVLW	B'11111111'
	MOVWF	TRISA			; CONFIGURA I/O DO PORTA

	MOVLW	B'11111111'
	MOVWF	TRISB			; CONFIGURA I/O DO PORTB

	MOVLW	B'11111101'
	MOVWF	TRISC			; CONFIGURA I/O DO PORTC

	MOVLW	B'00000000'
	MOVWF	TRISD			; CONFIGURA I/O DO PORTD

	MOVLW	B'00000100'
	MOVWF	TRISE			; CONFIGURA I/O DO PORTE

	MOVLW	B'11011111'
	MOVWF	OPTION_REG		; CONFIGURA OPTIONS
					; PULL-UPs DESABILITADOS
					; INTER. NA BORDA DE SUBIDA DO RB0
					; TIMER0 INCREM. PELO CICLO DE MÁQUINA
					; WDT   - 1:128
					; TIMER - 1:1
					
	MOVLW	B'00000000'		
	MOVWF	INTCON			; CONFIGURA INTERRUPÇÕES
					; DESABILITADA TODAS AS INTERRUPÇÕES

	MOVLW	B'00000111'
	MOVWF	ADCON1			; CONFIGURA CONVERSOR A/D
					; CONFIGURA PORTA E PORTE COMO I/O DIGITAL

	BANK0				; SELECIONA BANCO 0 DA RAM

;  AS INSTRUÇÕES A SEGUIR FAZEM COM QUE O PROGRAMA TRAVE QUANDO HOUVER UM
;  RESET OU POWER-UP, MAS PASSE DIRETO SE O RESET FOR POR WDT. DESTA FORMA,
;  SEMPRE QUE O PIC É LIGADO, O PROGRAMA TRAVA, AGUARDA UM ESTOURO DE WDT
;  E COMEÇA NOVAMENTE. ISTO EVITA PROBLEMAS NO START-UP DO PIC.

	BTFSC	STATUS,NOT_TO		; RESET POR ESTOURO DE WATCHDOG TIMER ?
	GOTO	$			; NÃO - AGUARDA ESTOURO DO WDT
					; SIM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         INICIALIZAÇÃO DA RAM                            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA IRÁ LIMPAR TODA A RAM DO BANCO 0, INDO DE 0X20 A 0X7F.

	MOVLW	0X20
	MOVWF	FSR			; APONTA O ENDEREÇAMENTO INDIRETO PARA
					; A PRIMEIRA POSIÇÃO DA RAM
LIMPA_RAM
	CLRF	INDF			; LIMPA A POSIÇÃO
	INCF	FSR,F			; INCREMENTA O PONTEIRO P/ A PRÓX. POS.
	MOVF	FSR,W
	XORLW	0X80			; COMPARA O PONTEIRO COM A ÚLT. POS. +1
	BTFSS	STATUS,Z		; JÁ LIMPOU TODAS AS POSIÇÕES?
	GOTO	LIMPA_RAM		; NÃO - LIMPA A PRÓXIMA POSIÇÃO
					; SIM

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *			  CONFIGURAÇÕES INICIAIS DO DISPLAY		    *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTA ROTINA INICIALIZA O DISPLAY P/ COMUNICAÇÃO DE 8 VIAS, DISPLAY PARA 2
; LINHAS, CURSOR APAGADO E DESLOCAMENTO DO CURSOR À DIREITA. 

INICIALIZACAO_DISPLAY
	BCF	RS			; SELECIONA O DISPLAY P/ COMANDOS

	MOVLW	0X30			; ESCREVE COMANDO 0X30 PARA
	CALL	ESCREVE			; INICIALIZAÇÃO

	MOVLW	.3
	CALL	DELAY_MS		; DELAY DE 3MS (EXIGIDO PELO DISPLAY)

	MOVLW	0X30			; ESCREVE COMANDO 0X30 PARA
	CALL	ESCREVE			; INICIALIZAÇÃO

	MOVLW	0X30			; ESCREVE COMANDO 0X30 PARA
	CALL	ESCREVE			; INICIALIZAÇÃO

	MOVLW	B'00111000'		; ESCREVE COMANDO PARA
	CALL	ESCREVE			; INTERFACE DE 8 VIAS DE DADOS

	MOVLW	B'00000001'		; ESCREVE COMANDO PARA
	CALL	ESCREVE			; LIMPAR TODO O DISPLAY

	MOVLW	.1
	CALL	DELAY_MS		; DELAY DE 1MS

	MOVLW	B'00001100'		; ESCREVE COMANDO PARA
	CALL	ESCREVE			; LIGAR O DISPLAY SEM CURSOR

	MOVLW	B'00000110'		; ESCREVE COMANDO PARA INCREM.
	CALL	ESCREVE			; AUTOMÁTICO À DIREITA

	BSF	RS			; SELECIONA O DISPLAY P/ DADOS

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         INICIALIZAÇÃO DA RAM                            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTE TRECHO DO PROGRAMA LÊ OS DADOS DAS MEMÓRIAS (E2PROM E FLASH) E
;  ATUALIZA A RAM.

LE_MEMORIA_PROGRAMA
	MOVLW	END_MEM_PROG_H
	MOVWF	ENDERECO_HIGH
	MOVLW	END_MEM_PROG_L
	MOVWF	ENDERECO_LOW		; CARREGA ENDERECO P/ LEITURA

	CALL	FLASH_PROGRAM_READ	; CHAMA ROTINA P/ LER DADO

	MOVF	DADO_HIGH_00,W
	MOVWF	VALOR_PROG_HIGH
	MOVF	DADO_LOW_00,W
	MOVWF	VALOR_PROG_LOW		; SALVA O DADO LIDO EM
					; VALOR_PROG_HIGH E VALOR_PROG_LOW
LE_MEMORIA_DADOS
	MOVLW	END_MEM_DADO
	MOVWF	ENDERECO_LOW		; CARREGA ENDERECO P/ LEITURA

	CALL	DATA_EEPROM_READ	; CHAMA ROTINA P/ LER DADO

	MOVF	DADO_LOW_00,W
	MOVWF	VALOR_DADOS		; SALVA DADO LIDO EM VALOR_DADOS


; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *               ROTINA DE ESCRITA DA TELA PRINCIPAL                       *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;  ESTA ROTINA ESCREVE A TELA PRINCIPAL DO PROGRAMA, COM AS FRASES:
;  LINHA 1 - "M.DADOS  M.PROG."
;  LINHA 2 - " >xxh<    xxxxh "

	CALL	ATUALIZA_TELA_LINHA_1	; ATUALIZA TELA LINHA 1 DO LCD

	CALL	ATUALIZA_TELA_LINHA_2	; ATUALIZA TELA LINHA 2 DO LCD

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                          VARREDURA DOS BOTÕES                           *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ESTA ROTINA VERIFICA SE ALGUM BOTÃO ESTÁ PRESSIONADO E CASO AFIRMATIVO
; DESVIA PARA O TRATAMENTO DO MESMO.

VARRE
	CLRWDT				; LIMPA WATCHDOG TIMER

; **************** VERIFICA ALGUM BOTÃO PRESSIONADO *************************

VARRE_BOTOES
	BTFSS	BOTAO_0			; O BOTÃO 0 ESTA PRESSIONADO ?
	GOTO	TRATA_BOTAO_0		; SIM - PULA P/ TRATA_BOTAO_0
					; NÃO

	BTFSS	BOTAO_1			; O BOTÃO 1 ESTA PRESSIONADO ?
	GOTO	TRATA_BOTAO_1		; SIM - PULA P/ TRATA_BOTAO_1
					; NÃO

	BTFSS	BOTAO_2			; O BOTÃO 2 ESTA PRESSIONADO ?
	GOTO	TRATA_BOTAO_2		; SIM - PULA P/ TRATA_BOTAO_2
					; NÃO

	BTFSS	BOTAO_3			; O BOTÃO 3 ESTA PRESSIONADO ?
	GOTO	TRATA_BOTAO_3		; SIM - PULA P/ TRATA_BOTAO_3
					; NÃO

; *************************** FILTRO P/ EVITAR RUIDOS ***********************

	MOVLW	FILTRO_TECLA		; CARREGA O VALOR DE FILTRO_TECLA
	MOVWF	FILTRO_BOTOES		; SALVA EM FILTRO_BOTOES
					; RECARREGA FILTRO P/ EVITAR RUIDOS
					; NOS BOTÕES
	MOVLW	.1
	MOVWF	TEMPO_TURBO		; CARREGA TEMPO DO TURBO DAS TECLAS
					; COM 1 - IGNORA O TURBO A PRIMEIRA
					; VEZ QUE A TECLA É PRESSIONADA

	GOTO	VARRE			; VOLTA PARA VARRER TECLADO

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                         TRATAMENTO DOS BOTÕES                           *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; NESTE TRECHO DO PROGRAMA ESTÃO TODOS OS TRATAMENTOS DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO 0 ***************************

TRATA_BOTAO_0
	MOVF	FILTRO_BOTOES,F
	BTFSC	STATUS,Z		; FILTRO JÁ IGUAL A ZERO ?
					; (FUNÇÃO JA FOI EXECUTADA?)		
	GOTO	VARRE			; SIM - VOLTA P/ VARREDURA DO TECLADO
					; NÃO
	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

	MOVLW	B'00000001'
	XORWF	FLAG,F			; INVERTE FLAG
					; ALTERA A MEMÓRIA UTILIZADA

	CALL	ATUALIZA_TELA_LINHA_2	; CHAMA ROTINA P/ ATUALIZAR LCD

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO 1 ***************************

TRATA_BOTAO_1
	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

	DECFSZ	TEMPO_TURBO,F		; FIM DO TEMPO DE TURBO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM
	MOVLW	TURBO_TECLA
	MOVWF	TEMPO_TURBO		; RECARREGA TEMPORIZADOR DO TURBO
					; DAS TECLAS

	BTFSC	TIPO_MEMORIA		; ESTÁ UTILIZANDO MEMÓRIA DE DADOS ?
	GOTO	INC_MEM_PROG		; NÃO - ENTÃO PULA P/ INC_MEM_PROG
					; SIM
INC_MEM_DADOS
	INCF	VALOR_DADOS,F		; INCREMENTA VALOR_DADOS

	CALL	ATUALIZA_TELA_LINHA_2	; CHAMA ROTINA P/ ATUALIZAR LCD

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

INC_MEM_PROG
	INCF	VALOR_PROG_LOW,F	; INCREMENTA VALOR_PROG_LOW
	BTFSC	STATUS,Z		; HOUVE ESTOURO ?
	INCF	VALOR_PROG_HIGH,F	; SIM - INCREMENTA VALOR_PROG_HIGH
					; NÃO

	MOVLW	B'00111111'
	ANDWF	VALOR_PROG_HIGH,F	; LIMITA CONTADOR DA MEMÓRIA DE
					; PROGRAMA EM 14 BITS

	CALL	ATUALIZA_TELA_LINHA_2	; CHAMA ROTINA P/ ATUALIZAR LCD

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO 2 ***************************

TRATA_BOTAO_2
	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

	DECFSZ	TEMPO_TURBO,F		; FIM DO TEMPO DE TURBO ?
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM
	MOVLW	TURBO_TECLA
	MOVWF	TEMPO_TURBO		; RECARREGA TEMPORIZADOR DO TURBO
					; DAS TECLAS

	BTFSC	TIPO_MEMORIA		; ESTÁ UTILIZANDO MEMÓRIA DE DADOS ?
	GOTO	DEC_MEM_PROG		; NÃO - ENTÃO PULA P/ DEC_MEM_PROG
					; SIM
DEC_MEM_DADOS
	DECF	VALOR_DADOS,F		; DECREMENTA VALOR_DADOS

	CALL	ATUALIZA_TELA_LINHA_2	; CHAMA ROTINA P/ ATUALIZAR LCD

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

DEC_MEM_PROG
	MOVLW	.1
	SUBWF	VALOR_PROG_LOW,F	; DECREMENTA VALOR_PROG_LOW
	BTFSS	STATUS,C		; HOUVE ESTOURO ?
	DECF	VALOR_PROG_HIGH,F	; SIM - DECREMENTA VALOR_PROG_HIGH
					; NÃO

	MOVLW	B'00111111'
	ANDWF	VALOR_PROG_HIGH,F	; LIMITA CONTADOR DA MEMÓRIA DE
					; PROGRAMA EM 14 BITS

	CALL	ATUALIZA_TELA_LINHA_2	; CHAMA ROTINA P/ ATUALIZAR LCD

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; ************************* TRATAMENTO DO BOTÃO 3 ***************************

TRATA_BOTAO_3
	MOVF	FILTRO_BOTOES,F
	BTFSC	STATUS,Z		; FILTRO JÁ IGUAL A ZERO ?
					; (FUNÇÃO JA FOI EXECUTADA?)		
	GOTO	VARRE			; SIM - VOLTA P/ VARREDURA DO TECLADO
					; NÃO
	DECFSZ	FILTRO_BOTOES,F		; FIM DO FILTRO ? (RUIDO?)
	GOTO	VARRE			; NÃO - VOLTA P/ VARRE
					; SIM - BOTÃO PRESSIONADO

; ********TRECHO DO PROGRAMA PARA GRAVAR DADOS DA RAM NA MEMÓRIA *************

GRAVA_MEMORIA_PROGRAMA
	MOVLW	END_MEM_PROG_H
	MOVWF	ENDERECO_HIGH
	MOVLW	END_MEM_PROG_L
	MOVWF	ENDERECO_LOW		; CARREGA ENDERECO ONDE O DADO SERÁ SALVO

	MOVF	VALOR_PROG_HIGH,W
	MOVWF	DADO_HIGH_00
	MOVF	VALOR_PROG_LOW,W
	MOVWF	DADO_LOW_00		; CARREGA DADO A SER SALVO
					; EM DADO_HIGH_00 E DADO_LOW_00

	CALL	FLASH_PROGRAM_WRITE	; CHAMA ROTINA DE GRAVAÇÃO

GRAVA_MEMORIA_DADOS
	MOVLW	END_MEM_DADO
	MOVWF	ENDERECO_LOW		; CARREGA ENDERECO ONDE O DADO SERÁ SALVO

	MOVF	VALOR_DADOS,W
	MOVWF	DADO_LOW_00		; CARREGA DADO A SER SALVO EM DADO_LOW_00

	CALL	DATA_EEPROM_WRITE	; CHAMA ROTINA DE GRAVAÇÃO

	GOTO	VARRE			; VOLTA P/ VARREDURA DOS BOTÕES

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                              FIM DO PROGRAMA                            *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END				; FIM DO PROGRAMA
